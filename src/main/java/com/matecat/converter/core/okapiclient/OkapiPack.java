package com.matecat.converter.core.okapiclient;

import java.io.File;
import java.util.Arrays;

/**
 * Class representing the 'pack' folder generated by Okapi Framework, which includes:
 * 1. Manifest file
 * 2. Original file
 * 3. Xliff file
 */
public class OkapiPack {

    // File and directory names
    public static final String MANIFEST_FILENAME = "manifest.rkm";
    public static final String ORIGINAL_DIRECTORY_NAME = "original";
    public static final String WORK_DIRECTORY_NAME = "work";

    // Inner files
    private File pack;
    private File xlf, manifest, originalFile;


    /**
     * Pack constructor
     * @param pack File wrapping the pack's folder
     */
    public OkapiPack(final File pack) {

        // Check that it is a valid pack
        if (pack == null  ||  !pack.exists()  ||  !pack.isDirectory()  ||  pack.listFiles().length == 0)
            throw new IllegalArgumentException("The given pack is not valid");

        // Save the pack and init the rest of files
        this.pack = pack;
        initFiles();

    }


    /**
     * Init the Xliff, the manifest and the original file.
     * It throws a RuntimeException if any of them is not found.
     */
    private void initFiles() {

        // Init the manifest (located in the root)
        Arrays.stream(pack.listFiles()).forEach(file -> {

            // Process subdirectories
            if (file.isDirectory()) {

                // Original file
                if (file.getName().equals(ORIGINAL_DIRECTORY_NAME)  &&  file.listFiles() != null)
                    this.originalFile = Arrays.stream(file.listFiles()).filter(f -> !f.isDirectory()).findFirst().get();

                // Xlf
                else if (file.getName().equals(WORK_DIRECTORY_NAME)  &&  file.listFiles() != null)
                    this.xlf = Arrays.stream(file.listFiles())
                            .filter(f -> !f.isDirectory()
                                    &&  f.getName().substring(f.getName().lastIndexOf('.')).equals(".xlf"))
                            .findFirst().get();

            }

            // Process manifest file
            else if (file.getName().equals(MANIFEST_FILENAME)) {
                this.manifest = file;
            }

         });

        // Check that all the files have been found
        if (this.manifest == null)
            throw new RuntimeException("The generated pack is corrupted (no manifest)");
        if (this.originalFile == null)
            throw new RuntimeException("The generated pack is corrupted (no original)");
        if (this.xlf == null)
            throw new RuntimeException("The generated pack is corrupted (no xliff)");

    }


    /**
     * Get path
     * @return Path of the pack
     */
    public String getPath() {
        return pack.getPath();
    }


    /**
     * Get pack folder
     * @return File wrapping the folder of the pack
     */
    public File getPackFolder() {
        return pack;
    }


    /**
     * Get Xlf
     * @return Get the xliff file contained inside the pack
     */
    public File getXlf() {
        return xlf;
    }


    /**
     * Get manifest
     * @return Get the manifest file contained inside the pack
     */
    public File getManifest() {
        return manifest;
    }


    /**
     * Get original file
     * @return Get the original file contained inside the pack
     */
    public File getOriginalFile() {
        return originalFile;
    }
}
